<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>在 Android 中使用 Render Node 加速渲染 | Xiao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-143241641-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">在 Android 中使用 Render Node 加速渲染</h1><a id="logo" href="/.">Xiao's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">在 Android 中使用 Render Node 加速渲染</h1><div class="post-meta">2023-01-16</div><div class="post-content"><p>在刚开始安卓开发的时候，前辈教导我：如果视图渲染出现了什么问题，就把硬件加速关掉。这确实让我绕开了不少显示上的问题。在后面的需求开发中，正好碰到了一个功能点：需要使用一个图片作为蒙层（称为蒙层图片），实际图片（称为内容图片）需要只在蒙层图片有不透明像素的地方显示，以实现对图片的特殊裁剪效果。</p>
<p>类似的功能已经做过很多次了，实现写起来也是信手拈来：</p>
<h2 id="使用-Canvas-绘制蒙层"><a href="#使用-Canvas-绘制蒙层" class="headerlink" title="使用 Canvas 绘制蒙层"></a>使用 Canvas 绘制蒙层</h2><p>将两张图片绘制到一起，需要使用到的是 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/graphics/PorterDuff.Mode"><code>PorterDuff.Mode</code></a> 混合模式，其中根据蒙层和实际图片绘制顺序的不同，可以选择使用的有 <code>DST_IN</code> 、 <code>SRC_ATOP</code> 等；在绘制时，可以调用 <code>Paint.setXfermode</code> 为画笔设置不同的混合模式，实现混合效果。</p>
<p>在绘制蒙层和图片时，画布 <code>Canvas</code> 上可能已经有其他元素存在了，直接叠加蒙层的话会在已有的内容上也使用像素混合效果，产生与预期不服的结果。为了避免类似的问题，需要在绘制蒙层图片和内容图片之前，使用 <code>Canvas.saveLayer</code> 将绘制的元素临时保存到另一个图层中，实现与画布现有元素互不干扰的效果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备绘制资源</span></span><br><span class="line"><span class="keyword">val</span> head = ContextCompat.getDrawable(context, R.drawable.head)</span><br><span class="line"><span class="keyword">val</span> mask = ContextCompat.getDrawable(context, R.drawable.mask)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> maskPaint = Paint().apply &#123;</span><br><span class="line">    <span class="comment">// 先画蒙层、再画内容，使用 SRC_IN 模式</span></span><br><span class="line">    xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    <span class="comment">// 保存原图图层，与画布上原有元素互不干扰</span></span><br><span class="line">    <span class="keyword">val</span> saveCount = canvas.saveLayer(maskRectF, <span class="literal">null</span>)</span><br><span class="line">    mask?.draw(canvas)</span><br><span class="line">    <span class="comment">// 保存蒙层图层，在恢复时使用 maskPaint 中设置的混合模式进行像素混合</span></span><br><span class="line">    <span class="keyword">val</span> layerCount = canvas.saveLayer(rectF, maskPaint)</span><br><span class="line">    head?.draw(canvas)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复图层以应用像素混合</span></span><br><span class="line">    canvas.restoreToCount(layerCount)</span><br><span class="line">    canvas.restoreToCount(saveCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接使用-Canvas-绘制蒙层的问题"><a href="#直接使用-Canvas-绘制蒙层的问题" class="headerlink" title="直接使用 Canvas 绘制蒙层的问题"></a>直接使用 Canvas 绘制蒙层的问题</h3><p>上面的代码已经能实现需求功能了，但是 <code>Canvas.saveLayer</code> 上的注释让我耿耿于怀：</p>
<blockquote>
<p>This behaves the same as save(), but in addition it allocates and redirects drawing to an offscreen rendering target.<br>Note: this method is <strong>very expensive</strong>, incurring more than double rendering cost for contained content. Avoid using this method when possible and instead use a hardware layer on a View to apply an xfermode, color filter, or alpha, as it will perform much better than this method.</p>
</blockquote>
<p>在这段节选的方法注释中可以得出几个结论：</p>
<ul>
<li>这个方法的调用开销<strong>十分昂贵</strong>，应当尽量避免使用；</li>
<li>调用此方法后<strong>将失去硬件加速效果</strong>，无法从GPU中获益。</li>
</ul>
<p>所以，我开始寻找使用其他途径实现这个功能的办法。</p>
<h2 id="安卓的-RenderNode-加速"><a href="#安卓的-RenderNode-加速" class="headerlink" title="安卓的 RenderNode 加速"></a>安卓的 RenderNode 加速</h2><p>前不久正好看到了一篇安卓团队发布的，介绍<a target="_blank" rel="noopener" href="https://medium.com/androiddevelopers/rendernode-for-bigger-better-blurs-ced9f108c7e2">使用RenderNode进行模糊绘制</a>的博客文章，其中介绍了如何在自定义控件中使用 <code>RenderNode</code> 进行高级的、定制化的渲染显示效果。其中吸引我关注的有以下几点：</p>
<ul>
<li>保持硬件加速特性，绘制性能优；</li>
<li>各种渲染效果可以自行组合叠加；</li>
<li>不同元素之间的效果和渲染不会冲突。</li>
</ul>
<p>这些特点正好能满足我在使用 <code>Canvas.saveLayer</code> 时所遇到的问题，于是赶紧学习一波 <code>RenderNode</code> 的使用姿势，并实现一下上面的功能。</p>
<h2 id="RenderNode-的使用"><a href="#RenderNode-的使用" class="headerlink" title="RenderNode 的使用"></a>RenderNode 的使用</h2><p>如上博文所说， <code>RenderNode</code> 是在 API 29 及以上系统才能公开访问的类。使用时先调用 <code>RenderNode.setPosition</code> 设置绘制的位置和范围，然后使用 <code>RenderNode.recordingCanvas</code> 获取一个 <code>RecordingCanvas</code> ，该画布在使用方式上与普通画布别无二致，但是会把开发者在上面的操作命令记录下来，在实际绘制时再执行，达到加速的目的。最后，使用 <code>Canvas.drawRenderNode</code> 将记录好内容的 <code>RenderNode</code> 绘制到目标视图的 <code>onDraw</code> 中传入的画布中，将其渲染到屏幕上。</p>
<h3 id="用-RenderNode-渲染蒙层"><a href="#用-RenderNode-渲染蒙层" class="headerlink" title="用 RenderNode 渲染蒙层"></a>用 RenderNode 渲染蒙层</h3><p>那么，就直接尝试一下使用 <code>RenderNode</code> 来实现同样的蒙层功能。</p>
<p>首先，为了避免在 <code>onDraw</code> 过程中重复创建新对象，我们应当在视图构建时就准备好需要的资源：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备绘制资源</span></span><br><span class="line"><span class="keyword">val</span> head = ContextCompat.getDrawable(context, R.drawable.head)</span><br><span class="line"><span class="keyword">val</span> mask = ContextCompat.getDrawable(context, R.drawable.mask)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备画笔，先画内容、再画蒙层，蒙层叠加在内容上，使用 DST_IN 模式</span></span><br><span class="line"><span class="keyword">val</span> paint = Paint().apply &#123;</span><br><span class="line">    blendMode = BlendMode.DST_IN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用两个 RenderNode 分别绘制内容和蒙层，再将两个 RenderNode 混合</span></span><br><span class="line"><span class="keyword">val</span> headRender = RenderNode(<span class="string">&quot;head&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> headMaskRender = RenderNode(<span class="string">&quot;head_mask&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在绘制时，实现思路与 <code>Canvas</code> 类似，需要使用到 <code>RenderNode.setUseCompositingLayer</code> ，将绘制的内容另外开辟空间保存，在更新到屏幕上时才进行实际的渲染和混合。而不同的是， <code>RenderNode.setUseCompositingLayer</code> 会将内容保存在显存空间中，能提高渲染速度，并且不影响内存使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个辅助函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> RenderNode.<span class="title">withRecording</span><span class="params">(block: (<span class="type">canvas</span>: <span class="type">Canvas</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    block(<span class="keyword">this</span>.beginRecording())</span><br><span class="line">    <span class="keyword">this</span>.endRecording()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line">    <span class="comment">// 将两个render node设置初始位置和大小</span></span><br><span class="line">    headRender.setPosition(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    headMaskRender.setPosition(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置分层绘制，并给蒙层设置paint</span></span><br><span class="line">    headRender.setUseCompositingLayer(<span class="literal">true</span>, <span class="literal">null</span>)</span><br><span class="line">    headMaskRender.setUseCompositingLayer(<span class="literal">true</span>, paint)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录蒙层内容</span></span><br><span class="line">    headMaskRender.withRecording &#123;</span><br><span class="line">        mask?.draw(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容实际绘制</span></span><br><span class="line">    headRender.withRecording &#123;</span><br><span class="line">        <span class="comment">// 先画内容</span></span><br><span class="line">        head?.draw(it)</span><br><span class="line">        <span class="comment">// 再将蒙层叠加上来</span></span><br><span class="line">        it.drawRenderNode(headMaskRender)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将混合结果输出到 view 中</span></span><br><span class="line">    canvas?.drawRenderNode(headRender)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是，我们就成功地使用 <code>RenderNode</code> 实现了蒙层混合的效果了。</p>
<h2 id="RenderNode-与-Canvas-的性能对比"><a href="#RenderNode-与-Canvas-的性能对比" class="headerlink" title="RenderNode 与 Canvas 的性能对比"></a>RenderNode 与 Canvas 的性能对比</h2><p>使用 <code>RenderNode</code> 进行蒙层渲染，实际收益能有多大？既然两种渲染方式都实现了，可以直接实现一个Demo进行对比，源代码将在文末贴上。</p>
<h3 id="温和场景的对比"><a href="#温和场景的对比" class="headerlink" title="温和场景的对比"></a>温和场景的对比</h3><p>首先模拟一个在普通场景下的性能表现：使用 <code>RecyclerView</code> 的纵向布局，模拟带有头像的内容列表中的表现，使用 <code>adb shell dumpsys gfxinfo</code> 获取demo应用的绘制信息。</p>
<blockquote>
<p>Stats since: 362520548662ns</p>
<p>Total frames rendered: 1393</p>
<p>Janky frames: 17 (1.22%)</p>
<p>50th percentile: 5ms</p>
<p>90th percentile: 5ms</p>
<p>95th percentile: 5ms</p>
<p>99th percentile: 11ms</p>
<p>Number Missed Vsync: 5</p>
<p>Number High input latency: 185</p>
<p>Number Slow UI thread: 9</p>
<p>Number Slow bitmap uploads: 0</p>
<p>Number Slow issue draw commands: 6</p>
<p>Number Frame deadline missed: 11</p>
<p>50th gpu percentile: 1ms</p>
<p>90th gpu percentile: 2ms</p>
<p>95th gpu percentile: 3ms</p>
<p>99th gpu percentile: 12ms</p>
</blockquote>
<p>同样的内容，如果使用 <code>Canvas</code> 进行绘制，输出如下</p>
<blockquote>
<p>Stats since: 362520548662ns</p>
<p>Total frames rendered: 2244</p>
<p>Janky frames: 69 (3.07%)</p>
<p>50th percentile: 5ms</p>
<p>90th percentile: 5ms</p>
<p>95th percentile: 5ms</p>
<p>99th percentile: 18ms</p>
<p>Number Missed Vsync: 7</p>
<p>Number High input latency: 279</p>
<p>Number Slow UI thread: 12</p>
<p>Number Slow bitmap uploads: 0</p>
<p>Number Slow issue draw commands: 17</p>
<p>Number Frame deadline missed: 25</p>
<p>50th gpu percentile: 1ms</p>
<p>90th gpu percentile: 2ms</p>
<p>95th gpu percentile: 6ms</p>
<p>99th gpu percentile: 12ms</p>
</blockquote>
<p>可以看出，使用 <code>RenderNode</code> 渲染的界面，在卡顿率上比 <code>Canvas</code> 有了明显的改善（ 3.07% -&gt; 1.22%），99分位的绘制时间也明显变少，可以认为使用 <code>RenderNode</code> 能降低这种工况下画面卡顿的概率。</p>
<p>如果绘制出页面绘制所耗时间的直方图，也能看出明显区别：</p>
<p><img src="https://i0.hdslb.com/bfs/new_dyn/bc9c71ac92fc2cb380ef40dcab9460761564902300.png" alt="RenderNode 一列"></p>
<p><img src="https://i0.hdslb.com/bfs/new_dyn/ccd9341cf8153c4074b56c1fc83a552b1564902300.png" alt="Canvas 一列"></p>
<p>可以看出，使用 <code>RenderNode</code> 的渲染时间已经明显比 <code>Canvas</code> 减少，单纯从平均总耗时来看，平均每帧绘制时间从 4.53ms 降低为 2.49ms，降幅达45%。</p>
<h3 id="极端场景的比对"><a href="#极端场景的比对" class="headerlink" title="极端场景的比对"></a>极端场景的比对</h3><p>将demo稍作修改，可以得到一个极端场景：使用 <code>GridLayoutManager</code>，在页面中显示每行4个的图像，将屏幕中出现的元素数量最大化，能更明显地看出双方的性能对比。</p>
<p>首先是 <code>RenderNode</code> 选手的数据：</p>
<blockquote>
<p>Stats since: 1675600047954ns</p>
<p>Total frames rendered: 490</p>
<p>Janky frames: 9 (1.84%)</p>
<p>50th percentile: 5ms</p>
<p>90th percentile: 5ms</p>
<p>95th percentile: 6ms</p>
<p>99th percentile: 24ms</p>
<p>Number Missed Vsync: 2</p>
<p>Number High input latency: 234</p>
<p>Number Slow UI thread: 4</p>
<p>Number Slow bitmap uploads: 0</p>
<p>Number Slow issue draw commands: 4</p>
<p>Number Frame deadline missed: 5</p>
<p>50th gpu percentile: 2ms</p>
<p>90th gpu percentile: 7ms</p>
<p>95th gpu percentile: 7ms</p>
<p>99th gpu percentile: 7ms</p>
</blockquote>
<p>虽然同屏元素多了3倍，但此时的绘制性能没有受到太多影响；而另一方面 <code>Canvas</code> 选手的表现：</p>
<blockquote>
<p>Stats since: 1675600047954ns</p>
<p>Total frames rendered: 912</p>
<p>Janky frames: 425 (46.60%)</p>
<p>50th percentile: 6ms</p>
<p>90th percentile: 24ms</p>
<p>95th percentile: 25ms</p>
<p>99th percentile: 34ms</p>
<p>Number Missed Vsync: 129</p>
<p>Number High input latency: 439</p>
<p>Number Slow UI thread: 93</p>
<p>Number Slow bitmap uploads: 0</p>
<p>Number Slow issue draw commands: 218</p>
<p>Number Frame deadline missed: 220</p>
<p>50th gpu percentile: 2ms</p>
<p>90th gpu percentile: 6ms</p>
<p>95th gpu percentile: 7ms</p>
<p>99th gpu percentile: 7ms</p>
</blockquote>
<p>可以看到， <code>Canvas</code> 在这种极端复杂的场景下性能表现退步极大，卡顿帧比例达到了46.60%，几乎是不可用的状态。</p>
<p>再看双方的绘制时间直方图：</p>
<p><img src="https://i0.hdslb.com/bfs/new_dyn/6bf08fa040a60fe795c71f3cc03d984a1564902300.png" alt="RenderNode 四列"></p>
<p><img src="https://i0.hdslb.com/bfs/new_dyn/f9f27839d0516764a456b87485b18a071564902300.png" alt="Canvas 四列"></p>
<p>在平均绘制时间上， <code>RenderNode</code> 仍然保持了2.81ms的优秀绘制时间，没有对用户造成影响；而 <code>Canvas</code> 在此种工况下的平均绘制时间来到了21.30ms，差出了一个数量级，使得应用无法保持60fps渲染效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过一个简单的demo可以看出，使用 <code>RenderNode</code> 进行复杂特性的渲染确实能保持相对较高的渲染效率，能提升用户体验。但它并不是万能的，首先 API level 29 的要求相信就已经能拦住绝大多数生产项目的使用，在不提升项目版本的情况下，只能为同一个功能点写两份代码，保留 <code>Canvas</code> 的实现以运行在低版本的手机上。</p>
<p>但，对我来说是探索安卓硬件加速渲染的第一步，是从 <code>把硬件加速关掉</code> 到主动从硬件加速中受益的转变。</p>
<p>以上实例项目已开源，<a target="_blank" rel="noopener" href="https://github.com/xiaozhikang0916/RenderNode">项目地址</a>。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>在 Android 中使用 Render Node 加速渲染</p><p><span>文章作者：</span>Xiao</p><p><span>发布时间：</span>2023-01-16</p><p><span>最后更新：</span>2023-01-17</p><p><span>原始链接：</span><a href="/blog/android-render-node/">https://blog.xiaozk.site/blog/android-render-node/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://blog.xiaozk.site/blog/android-render-node/"></i></span></p><p><span>版权声明：</span><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议（CC-BY-NC-4.0）</a>进行许可。</a></p></div><br><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a><a href="/tags/RenderNode/"><i class="fa fa-tag"></i>RenderNode</a><a href="/tags/Canvas/"><i class="fa fa-tag"></i>Canvas</a></div><div class="post-nav"><a class="next" href="/blog/coroutine-task/">使用协程组合管理业务逻辑</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.xiaozk.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a> <a href="/tags/Callback/" style="font-size: 15px;">Callback</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/forEach/" style="font-size: 15px;">forEach</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/ItemTouchHelper/" style="font-size: 15px;">ItemTouchHelper</a> <a href="/tags/Unittest/" style="font-size: 15px;">Unittest</a> <a href="/tags/Powermock/" style="font-size: 15px;">Powermock</a> <a href="/tags/mock-rule/" style="font-size: 15px;">mock rule</a> <a href="/tags/RuleChain/" style="font-size: 15px;">RuleChain</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Constructor/" style="font-size: 15px;">Constructor</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a> <a href="/tags/layout/" style="font-size: 15px;">layout</a> <a href="/tags/drawable/" style="font-size: 15px;">drawable</a> <a href="/tags/color/" style="font-size: 15px;">color</a> <a href="/tags/selector/" style="font-size: 15px;">selector</a> <a href="/tags/ItemAnimator/" style="font-size: 15px;">ItemAnimator</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 15px;">安卓</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">协程</a> <a href="/tags/RenderNode/" style="font-size: 15px;">RenderNode</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/ItemDecoration/" style="font-size: 15px;">ItemDecoration</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/android-render-node/">在 Android 中使用 Render Node 加速渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/coroutine-task/">使用协程组合管理业务逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animate-decoration/">RecyclerView 中为 ItemDecoration 应用动画</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animator-click/">RecyclerView 的 item 在动画过程中的点击事件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-drawable-color-selector/">Android xml 中 drawable、color 的混用与 selector</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/kotlin-lambda-param/">kotlin 中传入形参、返回不匹配的 lambda 表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/thoughts-of-android-mvvm/">Android 项目中使用 MVVM 模式的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/java-override-constructor/">java 构造方法的重载</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-test-rule-order/">Android 使用Powermock的单元测试的 Rule 顺序</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/item-touch-helper-section/">ItemTouchHelper实现拖动分组与定制</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Xiao's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>