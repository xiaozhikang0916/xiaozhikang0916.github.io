<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ItemTouchHelper实现拖动分组与定制 | Xiao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-143241641-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ItemTouchHelper实现拖动分组与定制</h1><a id="logo" href="/.">Xiao's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ItemTouchHelper实现拖动分组与定制</h1><div class="post-meta">2019-08-28</div><div class="post-content"><p>Android 在 RecyclerView 中使用了 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/support/v7/widget/helper/ItemTouchHelper">ItemTouchHelper</a> 来支持列表项的移动、横扫功能。<br>最近在项目中用到了这部分功能，并且有限定拖动触发区域、拖动范围限制的要求，在此做一点记录。</p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>要为 <code>RecyclerView</code> 用上 <code>ItemTouchHelper</code> ，需要自己实例化一个 <code>ItemTouchHelper</code> 并传入一个自定义的  <code>ItemTouchHelper.Callback</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> itemTouchHelper = ItemTouchHelper(</span><br><span class="line">    <span class="keyword">object</span> : ItemTouchHelper.Callback() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">itemTouchHelper.attachToRecyclerView(recyclerView)</span><br></pre></td></tr></table></figure>

<p>自己所需要的移动、横扫功能定制就由传入的 <code>Callback</code> 来定制。</p>
<p>在传入的 <code>Callback</code> 中，由3个需要实现的抽象方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getMovementFlags</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>, viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>)</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>

<p>这个方法用来判定一个 <code>ViewHolder</code> 支持什么样的方式移动，一般直接调用<code>makeMovementFlags(int fragFlags, int swipeFlags)</code> 方法，来构造这个 flag int ，如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> makeMovementFlags(ItemTouchHelper.UP or ItemTouchHelper.DOWN, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>表示所有的项目都支持往上和往下方向的拖动，不支持横扫手势。</p>
<p>与拖动、横扫手势对应的，有两个事件回调：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMove</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    target: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSwiped</span><span class="params">(viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, direction: <span class="type">Int</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>onMove</code> 在列表项被移动到一个新的位置上时被调用，我们在此处理数据交换的流程，如交换数据集中的位置、通知 <code>adapter</code> 更新；</p>
<p><code>onSwipe</code> 在触发横扫手势时被调用，用来更新界面以显示横扫后需要出现的操作按钮。</p>
<h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><p>在我的业务中，需要限制拖动触发区域，在手点在拖动锚点上时触发拖动操作，其余区域即使长按也不能拖动；列表在视觉上分为两部分，列表项不能在组间互相交换位置，只能在组内交换，因此需要有更深的定制操作。</p>
<h3 id="修改拖动触发时机"><a href="#修改拖动触发时机" class="headerlink" title="修改拖动触发时机"></a>修改拖动触发时机</h3><p><code>ItemTouchHelper</code> 的默认行为是长按列表项就触发拖动操作，我们需要修改触发时机，首先是禁用长按，只需要重载 <code>Callback</code> 的一个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> : ItemTouchHelper.Callback() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isLongPressDragEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为列表项中的 <code>view</code> 绑定点击事件，通过主动调用 <code>itemTouchHelper.startDrag(viewHolder)</code> 触发拖动事件：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dragAnchor.setOnTouchListener &#123; _, event -&gt;</span><br><span class="line">    <span class="keyword">when</span>(event.action) &#123;</span><br><span class="line">        MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">            itemTouchHelper.startDrag(<span class="keyword">this</span><span class="symbol">@ViewHolder</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拖动分组"><a href="#拖动分组" class="headerlink" title="拖动分组"></a>拖动分组</h3><p>在默认行为里，列表项可以拖动到任意其它列表项上，我们需要重载 <code>Callback.chooseDragTarget</code> ，实现拖动范围的限制。</p>
<p>首先观察这个方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewHolder <span class="title function_">chooseDropTarget</span><span class="params">(<span class="meta">@NonNull</span> ViewHolder selected, <span class="meta">@NonNull</span> List&lt;ViewHolder&gt; dropTargets, <span class="type">int</span> curX, <span class="type">int</span> curY)</span></span><br></pre></td></tr></table></figure>

<p>我们通过参数可以拿到当前被拖动的列表项，<br>以及可以被选为释放目标的其它列表项 <code>dropTargets</code> ，<br>而默认实现则是从 <code>dropTargets</code> 这个列表中选择最合适的释放位置。<br>那么我们就可以通过过滤不合适的释放位置，达到限制拖动的目的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">chooseDropTarget</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    selected: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    dropTargets: <span class="type">MutableList</span>&lt;<span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">    curX: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    curY: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: RecyclerView.ViewHolder? &#123;</span><br><span class="line">    <span class="keyword">val</span> filtered = dropTargets.filter &#123; isSameSection(target, it) &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.chooseDropTarget(selected, filtered, curX, curY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用kotlin时，切记要在重载方法时，将返回类型改为可空 <code>RecyclerView.ViewHolder?</code> ，以节约一次编译时间。</p>
</blockquote>
<h4 id="Updated"><a href="#Updated" class="headerlink" title="Updated"></a>Updated</h4><p>除了 <code>chooseDragTarget</code> ，我们还可以选择另一个方法实现拖动范围的限制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDropOver</span><span class="params">(RecyclerView recyclerView, ViewHolder current,</span></span><br><span class="line"><span class="params">                ViewHolder target)</span></span><br></pre></td></tr></table></figure>

<p>其作用是在拖动到其他项上方时，判断能不能释放在这些其他项的位置上。只有通过 <code>canDropOver</code> 筛选的 <code>ViewHolder</code> 才会出现在 <code>chooseDropTarget</code> 的 <code>dropTargets</code> 列表中。所以这个方法更适合做针对每一项的筛选操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canDropOver</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    current: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    target: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isSameSection(current, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拖动阴影"><a href="#拖动阴影" class="headerlink" title="拖动阴影"></a>拖动阴影</h3><p>在 <code>RecyclerView</code> 中，列表项的布局和绘制顺序一般来说是从上到下的，如果不加任何限制，可能会出现的情况是：<br>将某一项往下拖动时，会因为下面的视图绘制顺序比被拖动项更后，使得被拖动项被其它视图覆盖，不符合一般直观感受。</p>
<p><code>ItemTouchHelper</code> 对此的解决方案分为两种。在系统小于 <code>Lolipop 21</code> 的机子上，通过一个 <code>RecyclerView.ChildDrawingOrderCallback</code> 来更改绘制顺序，<br>保证被拖动项最后绘制，以免被其它视图覆盖。</p>
<p>在大于 21 的机子上，系统支持通过 <a target="_blank" rel="noopener" href="https://material.io/design/environment/elevation.html">elevation</a> 来控制视图的z轴前后关系，并实现阴影效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemTouchUIUtilImpl</span> <span class="keyword">implements</span> <span class="title class_">ItemTouchUIUtil</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ItemTouchUIUtil</span> <span class="variable">INSTANCE</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ItemTouchUIUtilImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDraw</span><span class="params">(Canvas c, RecyclerView recyclerView, View view, <span class="type">float</span> dX, <span class="type">float</span> dY,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> actionState, <span class="type">boolean</span> isCurrentlyActive)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCurrentlyActive) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">originalElevation</span> <span class="operator">=</span> view.getTag(R.id.item_touch_helper_previous_elevation);</span><br><span class="line">                <span class="keyword">if</span> (originalElevation == <span class="literal">null</span>) &#123;</span><br><span class="line">                    originalElevation = ViewCompat.getElevation(view);</span><br><span class="line">                    <span class="type">float</span> <span class="variable">newElevation</span> <span class="operator">=</span> <span class="number">1f</span> + findMaxElevation(recyclerView, view);</span><br><span class="line">                    ViewCompat.setElevation(view, newElevation);</span><br><span class="line">                    view.setTag(R.id.item_touch_helper_previous_elevation, originalElevation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        view.setTranslationX(dX);</span><br><span class="line">        view.setTranslationY(dY);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ItemTouchUIUtilImpl</code> 在大于21的机子上，会找到当前 <code>recyclerView</code> 中 <strong>除被拖动项以外</strong> <code>elevation</code> 的最大值，<br>并将最大值 <strong>+1 px</strong> 设置给被拖动项，以达到被拖动项在所有项目之上的效果，并且在手势完成后恢复为原来的值。这里有两点需要注意的：</p>
<ol>
<li>拖动时的 <code>elevation</code> 的差值固定为 1px，没有提供定制；</li>
<li>拖动时的 <code>elevation</code> 值与自己的原值无关，因此不能通过拖动开始时修改 <code>elevation</code> 来达到定制效果；</li>
</ol>
<p>因为上述的 2 ，如果我们需要定制拖动时的阴影效果，我们需要另外一种方式来控制z轴的前后关系：</p>
<blockquote>
<p>z &#x3D; elevation + translationZ</p>
</blockquote>
<p>我们可以在拖动前后修改视图的 <code>translationZ</code> 值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSelectedChanged</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    actionState: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState)</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        viewHolder?.itemView?.let &#123;</span><br><span class="line">            <span class="comment">// add 1 dp to final z</span></span><br><span class="line">            ViewCompat.setTranslationZ(it, <span class="number">3f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clearView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder)</span><br><span class="line">    ViewCompat.setTranslationZ(viewHolder.itemView, <span class="number">0f</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，对拖动效果的定制就完成了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>为了验证上述关于 <code>elevation</code> 的两个结论，我们可以做一点好玩的事情：</p>
<h3 id="elevation-值固定"><a href="#elevation-值固定" class="headerlink" title="elevation 值固定"></a>elevation 值固定</h3><p>拖动时的 <code>elevation</code> 的差值固定为 1px，没有提供定制。如果我们尝试修改被拖动项的 <code>elevation</code> ，将没有效果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSelectedChanged</span><span class="params">(viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, actionState: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState)</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        viewHolder?.itemView?. let &#123;</span><br><span class="line">            <span class="comment">//无效</span></span><br><span class="line">            ViewCompat.setElevation(it, <span class="number">3f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="elevation-值与自己无关"><a href="#elevation-值与自己无关" class="headerlink" title="elevation 值与自己无关"></a>elevation 值与自己无关</h3><p>因为被拖动项的 <code>elevation</code> 值与自己的原值无关，而是当前列表的最大值 +1 px，可以通过触发拖动时随意修改一个项的 <code>elevation</code> 来验证：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSelectedChanged</span><span class="params">(viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, actionState: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState)</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        <span class="comment">// set the first child&#x27;s elevation to 20 when some item is being dragged</span></span><br><span class="line">        (<span class="number">0</span> until recyclerView.childCount).asSequence().map &#123;</span><br><span class="line">            recyclerView.getChildAt(it)</span><br><span class="line">        &#125;.filter &#123; it <span class="keyword">is</span> LinearLayout &#125;.first().apply &#123;</span><br><span class="line">            ViewCompat.setElevation(<span class="keyword">this</span>, <span class="number">10f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder?.itemView?. let &#123;</span><br><span class="line">            ViewCompat.setElevation(it, <span class="number">20f</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clearView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    viewHolder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder)</span><br><span class="line">    (<span class="number">0</span> until recyclerView.childCount).asSequence().map &#123;</span><br><span class="line">        recyclerView.getChildAt(it)</span><br><span class="line">    &#125;.filter &#123; it <span class="keyword">is</span> LinearLayout &#125;.first().apply &#123;</span><br><span class="line">        ViewCompat.setElevation(<span class="keyword">this</span>, <span class="number">0f</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    viewHolder.itemView. let &#123;</span><br><span class="line">        ViewCompat.setElevation(it, <span class="number">0f</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察到的现象：</p>
<ul>
<li>如果被拖动的是列表第一项，他的z会变成 1px；</li>
<li>如果被拖动的不是第一项，那么第一项的z会变成 10px，被拖动的z变成 11px。</li>
</ul>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>ItemTouchHelper实现拖动分组与定制</p><p><span>文章作者：</span>Xiao</p><p><span>发布时间：</span>2019-08-28</p><p><span>最后更新：</span>2023-12-04</p><p><span>原始链接：</span><a href="/blog/item-touch-helper-section/">https://blog.xiaozk.site/blog/item-touch-helper-section/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://blog.xiaozk.site/blog/item-touch-helper-section/"></i></span></p><p><span>版权声明：</span><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议（CC-BY-NC-4.0）</a>进行许可。</a></p></div><br><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a><a href="/tags/RecyclerView/"><i class="fa fa-tag"></i>RecyclerView</a><a href="/tags/ItemTouchHelper/"><i class="fa fa-tag"></i>ItemTouchHelper</a></div><div class="post-nav"><a class="pre" href="/blog/android-test-rule-order/">Android 使用Powermock的单元测试的 Rule 顺序</a><a class="next" href="/blog/kotlin-loop-break/">Kotlin 中 forEach 的中断</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.xiaozk.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a> <a href="/tags/Callback/" style="font-size: 15px;">Callback</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/forEach/" style="font-size: 15px;">forEach</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/Unittest/" style="font-size: 15px;">Unittest</a> <a href="/tags/Powermock/" style="font-size: 15px;">Powermock</a> <a href="/tags/mock-rule/" style="font-size: 15px;">mock rule</a> <a href="/tags/RuleChain/" style="font-size: 15px;">RuleChain</a> <a href="/tags/ItemTouchHelper/" style="font-size: 15px;">ItemTouchHelper</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Constructor/" style="font-size: 15px;">Constructor</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a> <a href="/tags/layout/" style="font-size: 15px;">layout</a> <a href="/tags/drawable/" style="font-size: 15px;">drawable</a> <a href="/tags/color/" style="font-size: 15px;">color</a> <a href="/tags/selector/" style="font-size: 15px;">selector</a> <a href="/tags/ItemAnimator/" style="font-size: 15px;">ItemAnimator</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 15px;">安卓</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">协程</a> <a href="/tags/RenderNode/" style="font-size: 15px;">RenderNode</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/State/" style="font-size: 15px;">State</a> <a href="/tags/Event/" style="font-size: 15px;">Event</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/Flow/" style="font-size: 15px;">Flow</a> <a href="/tags/ItemDecoration/" style="font-size: 15px;">ItemDecoration</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/shate-and-event/">我对“状态”与“事件”的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-render-node/">在 Android 中使用 Render Node 加速渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/coroutine-task/">使用协程组合管理业务逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animate-decoration/">RecyclerView 中为 ItemDecoration 应用动画</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animator-click/">RecyclerView 的 item 在动画过程中的点击事件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-drawable-color-selector/">Android xml 中 drawable、color 的混用与 selector</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/kotlin-lambda-param/">kotlin 中传入形参、返回不匹配的 lambda 表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/thoughts-of-android-mvvm/">Android 项目中使用 MVVM 模式的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/java-override-constructor/">java 构造方法的重载</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-test-rule-order/">Android 使用Powermock的单元测试的 Rule 顺序</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Xiao's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>