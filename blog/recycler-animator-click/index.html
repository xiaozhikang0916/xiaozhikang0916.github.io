<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RecyclerView 的 item 在动画过程中的点击事件 | Xiao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-143241641-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RecyclerView 的 item 在动画过程中的点击事件</h1><a id="logo" href="/.">Xiao's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RecyclerView 的 item 在动画过程中的点击事件</h1><div class="post-meta">2020-04-26</div><div class="post-content"><p>在项目中应用了 MVVM 模式之后，就能享受到 <code>DiffUtil</code> 带来的计算最小变动集的便利性，以及在列表项更新时能用上自带动画。</p>
<p>但是因为页面更新应用了动画，使得页面响应点击时出现了问题。</p>
<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>在我的页面中，列表每一项都带有一个订阅按钮，对应数据有一个 “是否已经订阅” 的字段。每次点击按钮时，都根据目前数据是否已经订阅，向服务器发送订阅或者取消订阅的请求，然后根据请求的返回结果是否成功，使用 <code>DiffUtil</code> 更新当前页面列表项。</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemViewHolder</span></span>(itemView: View, <span class="keyword">private</span> <span class="keyword">val</span> onCheck: ((<span class="built_in">Int</span>, <span class="built_in">Boolean</span>) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span>) :</span><br><span class="line">    RecyclerView.ViewHolder(itemView) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> <span class="keyword">data</span>: Item? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> titleView = itemView.findViewById&lt;TextView&gt;(R.id.title)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> checkButton = itemView.findViewById&lt;TextView&gt;(R.id.button)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        checkButton.setOnClickListener(::onClick)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        onCheck?.invoke(adapterPosition, <span class="keyword">data</span>?.checked ?: <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(bindData: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span> = bindData</span><br><span class="line">        titleView.text = bindData.title</span><br><span class="line">        checkButton.isSelected = bindData.checked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>(</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Long</span>,</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">var</span> checked: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>代码看起来很美好，但是测试反馈过来说：快速多次点击按钮时，会重复发出完全一样的请求，而后续的请求则毫无疑问地失败了。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>得知问题后，马上开始开始着手分析。经过不停地断点调试和输出 log 之后（过程省略），会发现连续点击时，响应点击事件的 View 及其 ViewHolder 都一直是同一个对象；在替换动画播放完成后再次点击，响应点击事件的就变成了一个新的 View 了。</p>
<p>继续深入研究， RecyclerView 的动画默认是在 <code>DefaultItemAnimator</code> 中实现的。 而对于拥有相同 id 的数据，仅仅是其中的部分数据有更新，没有进行位置变换的话， <code>DiffUtil</code> 会调用 adapter 的 <code>notifyItemChanged</code> 方法通知更新。 <code>Change</code> 的动画在 <code>DefaultItemAnimator</code> 中的实现可以参见方法 <code>animateChangeImpl</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animateChangeImpl</span><span class="params">(<span class="keyword">final</span> ChangeInfo changeInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecyclerView.ViewHolder holder = changeInfo.oldHolder;</span><br><span class="line">    <span class="keyword">final</span> View view = holder == <span class="keyword">null</span> ? <span class="keyword">null</span> : holder.itemView;</span><br><span class="line">    <span class="keyword">final</span> RecyclerView.ViewHolder newHolder = changeInfo.newHolder;</span><br><span class="line">    <span class="keyword">final</span> View newView = newHolder != <span class="keyword">null</span> ? newHolder.itemView : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewPropertyAnimator oldViewAnim = view.animate().setDuration(</span><br><span class="line">                getChangeDuration());</span><br><span class="line">        mChangeAnimations.add(changeInfo.oldHolder);</span><br><span class="line">        oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX);</span><br><span class="line">        oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY);</span><br><span class="line">        oldViewAnim.alpha(<span class="number">0</span>).setListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                dispatchChangeStarting(changeInfo.oldHolder, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                oldViewAnim.setListener(<span class="keyword">null</span>);</span><br><span class="line">                view.setAlpha(<span class="number">1</span>);</span><br><span class="line">                view.setTranslationX(<span class="number">0</span>);</span><br><span class="line">                view.setTranslationY(<span class="number">0</span>);</span><br><span class="line">                dispatchChangeFinished(changeInfo.oldHolder, <span class="keyword">true</span>);</span><br><span class="line">                mChangeAnimations.remove(changeInfo.oldHolder);</span><br><span class="line">                dispatchFinishedWhenDone();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ViewPropertyAnimator newViewAnimation = newView.animate();</span><br><span class="line">        mChangeAnimations.add(changeInfo.newHolder);</span><br><span class="line">        newViewAnimation.translationX(<span class="number">0</span>).translationY(<span class="number">0</span>).setDuration(getChangeDuration())</span><br><span class="line">                .alpha(<span class="number">1</span>).setListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                        dispatchChangeStarting(changeInfo.newHolder, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animator)</span> </span>&#123;</span><br><span class="line">                        newViewAnimation.setListener(<span class="keyword">null</span>);</span><br><span class="line">                        newView.setAlpha(<span class="number">1</span>);</span><br><span class="line">                        newView.setTranslationX(<span class="number">0</span>);</span><br><span class="line">                        newView.setTranslationY(<span class="number">0</span>);</span><br><span class="line">                        dispatchChangeFinished(changeInfo.newHolder, <span class="keyword">false</span>);</span><br><span class="line">                        mChangeAnimations.remove(changeInfo.newHolder);</span><br><span class="line">                        dispatchFinishedWhenDone();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得知， <code>DefaultItemAnimator</code> 对于 change 的动画实现是将旧的 viewHolder 的不透明度 (alpha) 渐变到0，将新的 viewHolder 的不透明度渐变到1。呈现出来的效果便是在同一个位置，旧 viewHolder 淡出，被淡入的新 viewHolder 替换。</p>
<p>而上述点击的问题就出在动画播放过程中，点击事件被即将消失的旧 viewHolder 捕获了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在知道问题原因之后，就需要开始找解决办法了。既然问题原因出在动画播放过程中的点击响应，那么解决的思路应该是：在动画播放过程中不接受点击事件的分发，在动画播放完成后恢复响应。对此我想出了几个解决的思路。</p>
<h3 id="业务方处理点击的生效和禁用"><a href="#业务方处理点击的生效和禁用" class="headerlink" title="业务方处理点击的生效和禁用"></a>业务方处理点击的生效和禁用</h3><p>最开始的思路是，既然点击事件的监听是在 ViewHolder 中设置的，那么在需要禁用和启用对应事件的时候，由 ViewHolder 自行判断就好了。然而紧接着遇到的问题是， ViewHolder 能收到的外部通知仅仅是 adapter 中的 <code>onBindViewHolder</code> ，它在动画开始前就被调用，而动画完成后没有任何事件通知，因此无法实现点击事件的响应恢复。</p>
<p>另一个问题在于，如果将这一步交给业务方的 ViewHolder 自行实现，将会出现大量的模版代码，不利于项目的维护。</p>
<p>基于这两个原因，这一个思路连实验代码都没有写便被我放弃了。</p>
<h3 id="Animator-中自动设置是否响应点击"><a href="#Animator-中自动设置是否响应点击" class="headerlink" title="Animator 中自动设置是否响应点击"></a>Animator 中自动设置是否响应点击</h3><p>既然问题出在动画过程中，而系统也为我们开放了动画管理的接口，那么很自然地会想到自己复写动画的开始和结束，对应设置点击的启用与否。</p>
<p>在上面的 <code>animateChangeImpl</code> 代码中，可以看到第 15 行和第 37 行分别调用了 <code>dispatchChangeStarting</code> ，并且将当前传入的 viewHolder 是新是旧也作为参数传入，正适合我们进行控制，马上开始尝试：</p>
<p>ClickAnimator.kt：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickItemAnimator</span> : <span class="type">DefaultItemAnimator</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeStarting</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChangeStarting(item, oldItem)</span><br><span class="line">        item?.itemView?.isClickable = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeFinished</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChangeFinished(item, oldItem)</span><br><span class="line">        item?.itemView?.isClickable = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的设想中，动画开始时直接禁用整个 itemView 的是否可点击属性，在动画播放完成后将其恢复就能实现想要的效果。然而实际运行起来发现问题依旧，经过分析可知 <code>isClickable</code> 属性仅对单个 view 有效，其中的子 view 不受影响，而再次尝试 <code>enable</code> 属性也是如此，那么便只能尝试将其子 view 都进行设置了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickItemAnimator</span> : <span class="type">DefaultItemAnimator</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeStarting</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChangeStarting(item, oldItem)</span><br><span class="line">        item.itemView?.let &#123; setClickable(it, <span class="literal">false</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeFinished</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChangeFinished(item, oldItem)</span><br><span class="line">        item.itemView?.let &#123; setClickable(it, <span class="literal">true</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setClickable</span><span class="params">(view: <span class="type">View</span>, clickable: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        view.isClickable = clickable</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">is</span> ViewGroup) &#123;</span><br><span class="line">            view.children.filter &#123; it.visibility == View.VISIBLE &#125;.forEach &#123; setClickable(it, clickable) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而在实际运行前便想到了另一个问题： itemView 中不一定每一个子 view 都是需要响应点击的，我们不应该在动画完成后遍历设置，否则可能会破坏其原有的业务功能；暂存其原本的属性也不现实，会需要维护一个巨大的缓存池，并且维护其与实际的 itemView 的对应关系也需要巨大的精力。</p>
<h4 id="为-itemView-嵌套自定义-View-，按需拦截点击事件"><a href="#为-itemView-嵌套自定义-View-，按需拦截点击事件" class="headerlink" title="为 itemView 嵌套自定义 View ，按需拦截点击事件"></a>为 itemView 嵌套自定义 View ，按需拦截点击事件</h4><p>如果不可以遍历设置 itemView 中的点击属性，一个折衷的办法可以是自定义一个 ViewGroup ，响应 Animator 的设置，按需拦截传入的点击事件。</p>
<p>然而这个办法需要修改 itemView 的根布局，不适合接入到已有的项目中；而且多一层布局嵌套可能会对绘制性能产生影响，因此这个方法没有进行尝试验证。</p>
<h3 id="Animator-分发事件，业务自行响应"><a href="#Animator-分发事件，业务自行响应" class="headerlink" title="Animator 分发事件，业务自行响应"></a>Animator 分发事件，业务自行响应</h3><p>既然上述两个思路都有各自的缺陷而不可行，那么可以将两个方案组合起来各取优点使用：由 Animator 进行动画的开始、结束事件分发，各业务的 ViewHolder 按需进行响应的接入，达到按需响应、改动量小的目标：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickItemAnimator</span> : <span class="type">DefaultItemAnimator</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeStarting</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        (item <span class="keyword">as</span>? OnItemAnimationListener)?.onItemAnimationStatus(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">super</span>.onChangeStarting(item, oldItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeFinished</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        (item <span class="keyword">as</span>? OnItemAnimationListener)?.onItemAnimationStatus(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">super</span>.onChangeFinished(item, oldItem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnItemAnimationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onItemAnimationStatus</span><span class="params">(shouldClickEnabled: <span class="type">Boolean</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickItemViewHolder</span></span>(itemView: View, onCheck: ((<span class="built_in">Int</span>, <span class="built_in">Boolean</span>) -&gt; <span class="built_in">Unit</span>)) :</span><br><span class="line">    ItemViewHolder(itemView, onCheck), OnItemAnimationListener &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> handleClick = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        onCheck?.takeIf &#123; handleClick &#125;?.invoke(adapterPosition, <span class="keyword">data</span>?.checked ?: <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemAnimationStatus</span><span class="params">(shouldClickEnabled: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        handleClick = shouldClickEnabled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(bindData: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">        handleClick = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">super</span>.bind(bindData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，需要在动画过程中禁用点击的 viewHolder 自行实现接口 <code>OnItemAnimationListener</code> ，根据其传入参数设置标记位；在实际点击事件中判断标记位属性值，来决定是否需要发起业务逻辑。这样需要修改的代码量少，同时也不会对原有的业务逻辑产生影响。</p>
<h3 id="使用-TAG-暂存点击属性，遍历子view（更新）"><a href="#使用-TAG-暂存点击属性，遍历子view（更新）" class="headerlink" title="使用 TAG 暂存点击属性，遍历子view（更新）"></a>使用 TAG 暂存点击属性，遍历子view（更新）</h3><p>（后续更新）</p>
<p>在项目中使用了方法 3 之后，我仍在思考有没有更加方便地结局问题的办法。方法 2 其原本的弊端在于不能在恢复点击时将全部子 view 都设置成可点击的，需要有一个方便取用的位置记录其原本的属性，其实有一个方便的位置，即存在 view 的 tag 里面：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagAnimator</span> : <span class="type">DefaultItemAnimator</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeStarting</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        item?.itemView?.let(::setTag)</span><br><span class="line">        <span class="keyword">super</span>.onChangeStarting(item, oldItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChangeFinished</span><span class="params">(item: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>?, oldItem: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        item?.itemView?.let(::restoreTag)</span><br><span class="line">        <span class="keyword">super</span>.onChangeFinished(item, oldItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setTag</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> clickable = view.isClickable</span><br><span class="line">        view.setTag(R.id.tag_id, clickable)</span><br><span class="line">        view.isClickable = <span class="literal">false</span></span><br><span class="line">        iteratorView(view, ::setTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreTag</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> clickable = view.getTag(R.id.tag_id)</span><br><span class="line">        view.isClickable = clickable <span class="keyword">as</span>? <span class="built_in">Boolean</span> ?: <span class="literal">false</span></span><br><span class="line">        iteratorView(view, ::restoreTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">iteratorView</span><span class="params">(view: <span class="type">View</span>, action: ((<span class="type">View</span>) -&gt; <span class="type">Unit</span>))</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">is</span> ViewGroup) &#123;</span><br><span class="line">            view.children.forEach(action)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法能快速地应用到需要使用的地方，不需要对业务 viewHolder 进行额外的修改，但是失去了可定制性。我认为在使用上跟方法 3 是不相上下的。</p>
<h2 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h2><p>我把上面的问题与解决做成了一个 demo 项目：<a target="_blank" rel="noopener" href="https://github.com/xiaozhikang0916/ItemAnimatorBlockClick">ItemAnimatorBlockClick</a>。</p>
<p>在页面底部点击 <code>Default</code> 按钮可以显示原本有问题的页面，点击一个 <code>Check</code> 按钮后，对应列表项将会开始替换动画（动画时间被延长到 1.5s 方便观察）；在动画过程中再次点击同一个按钮，将会看到一个 <code>error</code> 的 log 输出，因为传入的状态与数据中存有的状态不符，并且按钮动画消失，马上转变回原有的样子。</p>
<p><code>Click</code> 按钮可以显示使用方法 3 修复的页面，重复上述操作会发现在动画过程中，重复的点击事件不会被响应，也不会看到 <code>error</code> 的 log 输出，直到动画播放完成后才能正确响应下一次点击。</p>
<p><code>Tag</code>  按钮可以显示使用方法 4 修复的页面，其表现与前一个页面没有区别。</p>
<h2 id="后文"><a href="#后文" class="headerlink" title="后文"></a>后文</h2><p>在项目中，大部分页面都直接调用了 <code>adapter.notifyDataSetChanged</code> 方法，直接刷新整个页面的数据。这样做确实有其便利性，不用考虑在什么地方具体发生了怎样的更新、不用担心动画执行的时间里发生问题。然而尽可能地使用到系统原生提供的工具和动画支持，也是提高用户体验的一个方向，在遇到问题 -&gt; 解决问题的过程中，自己也能得到学习提高的机会。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>RecyclerView 的 item 在动画过程中的点击事件</p><p><span>文章作者：</span>Xiao</p><p><span>发布时间：</span>2020-04-26</p><p><span>最后更新：</span>2023-01-17</p><p><span>原始链接：</span><a href="/blog/recycler-animator-click/">https://blog.xiaozk.site/blog/recycler-animator-click/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://blog.xiaozk.site/blog/recycler-animator-click/"></i></span></p><p><span>版权声明：</span><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议（CC-BY-NC-4.0）</a>进行许可。</a></p></div><br><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a><a href="/tags/RecyclerView/"><i class="fa fa-tag"></i>RecyclerView</a><a href="/tags/ItemAnimator/"><i class="fa fa-tag"></i>ItemAnimator</a></div><div class="post-nav"><a class="pre" href="/blog/recycler-animate-decoration/">RecyclerView 中为 ItemDecoration 应用动画</a><a class="next" href="/blog/android-drawable-color-selector/">Android xml 中 drawable、color 的混用与 selector</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.xiaozk.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a> <a href="/tags/Callback/" style="font-size: 15px;">Callback</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/forEach/" style="font-size: 15px;">forEach</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/ItemTouchHelper/" style="font-size: 15px;">ItemTouchHelper</a> <a href="/tags/Unittest/" style="font-size: 15px;">Unittest</a> <a href="/tags/Powermock/" style="font-size: 15px;">Powermock</a> <a href="/tags/mock-rule/" style="font-size: 15px;">mock rule</a> <a href="/tags/RuleChain/" style="font-size: 15px;">RuleChain</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Constructor/" style="font-size: 15px;">Constructor</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a> <a href="/tags/layout/" style="font-size: 15px;">layout</a> <a href="/tags/drawable/" style="font-size: 15px;">drawable</a> <a href="/tags/color/" style="font-size: 15px;">color</a> <a href="/tags/selector/" style="font-size: 15px;">selector</a> <a href="/tags/ItemAnimator/" style="font-size: 15px;">ItemAnimator</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 15px;">安卓</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">协程</a> <a href="/tags/RenderNode/" style="font-size: 15px;">RenderNode</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/ItemDecoration/" style="font-size: 15px;">ItemDecoration</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/android-render-node/">在 Android 中使用 Render Node 加速渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/coroutine-task/">使用协程组合管理业务逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animate-decoration/">RecyclerView 中为 ItemDecoration 应用动画</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animator-click/">RecyclerView 的 item 在动画过程中的点击事件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-drawable-color-selector/">Android xml 中 drawable、color 的混用与 selector</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/kotlin-lambda-param/">kotlin 中传入形参、返回不匹配的 lambda 表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/thoughts-of-android-mvvm/">Android 项目中使用 MVVM 模式的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/java-override-constructor/">java 构造方法的重载</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-test-rule-order/">Android 使用Powermock的单元测试的 Rule 顺序</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/item-touch-helper-section/">ItemTouchHelper实现拖动分组与定制</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Xiao's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>