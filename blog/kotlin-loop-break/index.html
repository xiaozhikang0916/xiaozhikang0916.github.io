<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="referrer" content="no-referrer"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Kotlin 中 forEach 的中断 | Xiao's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-143241641-1','auto');ga('send','pageview');
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kotlin 中 forEach 的中断</h1><a id="logo" href="/.">Xiao's Blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kotlin 中 forEach 的中断</h1><div class="post-meta">2019-07-11</div><div class="post-content"><h2 id="想要一个-break"><a href="#想要一个-break" class="headerlink" title="想要一个 break"></a>想要一个 <code>break</code></h2><p>相较于原生的 <code>for</code> 关键字， kotlin （包括 1.8 版本后的 Java） 为集合引入了符合函数式编程范式的 <code>forEach</code> 方法，提升了代码编写的体验。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">data</span>.forEach &#123;</span><br><span class="line">    println(<span class="string">&quot;Parsing <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> parsedData = it.toInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，随着业务发展，我发现需要在以前的 <code>forEach</code> 循环中加入条件，满足某些条件后直接退出循环，也就是说需要一个 <code>break</code> 关键字。</p>
<h2 id="forEach-有没有-break"><a href="#forEach-有没有-break" class="headerlink" title="forEach 有没有 break"></a><code>forEach</code> 有没有 <code>break</code></h2><p>查看 kotlin 库中 <code>forEach</code> 的源码会发现， <code>forEach</code> 并不是一个原生的关键字，而是库为我们包装好的内联函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (element <span class="keyword">in</span> <span class="keyword">this</span>) action(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们在花括号中传入的代码块最后会被处理为 lambda 函数传入，在其内部的 <code>for</code> 语句中实现循环；而在一段函数中当然不能中断函数外的循环了。</p>
<h2 id="怎么实现一个-break"><a href="#怎么实现一个-break" class="headerlink" title="怎么实现一个 break"></a>怎么实现一个 <code>break</code></h2><p>既然库中没有提供一个 <code>break</code> 关键字，那么我们当然要自己造一个轮子出来了。</p>
<h3 id="1-返回这个方法"><a href="#1-返回这个方法" class="headerlink" title="1. 返回这个方法"></a>1. 返回这个方法</h3><p>查看源码后的第一反应，满足中断条件就应当是不执行后面的处理逻辑，那么直接使用返回不就好了吗？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> parsed = <span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>.forEach &#123;</span><br><span class="line">    <span class="keyword">if</span> (it.toInt() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">    &#125;</span><br><span class="line">    parsed += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">3</span>, parsed) <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<p>然而仔细考虑就会发现这种其实很有问题：循环并不是真正地被中断，完整地走完了循环，只是部分数据没有进行操作而已：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> before = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> after = <span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>.forEach &#123;</span><br><span class="line">    before += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (it.toInt() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@forEach</span></span><br><span class="line">    &#125;</span><br><span class="line">    after += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">3</span>, after) <span class="comment">// 0 1 2</span></span><br><span class="line">assertEquals(<span class="number">3</span>, before) <span class="comment">// FAILED!!! actually 5</span></span><br></pre></td></tr></table></figure>

<p>这是 <code>Continue</code> ， 不是 <code>break</code>。</p>
<h3 id="2-暴力中断"><a href="#2-暴力中断" class="headerlink" title="2. 暴力中断"></a>2. 暴力中断</h3><p><code>break</code> 中断本质是想要从循环体中直接退出到循环外，那么最简单的办法…</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoopBreakException</span>: <span class="type">Throwable</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> before = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> after = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">data</span>.forEach &#123;</span><br><span class="line">        before += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (it.toInt() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> LoopBreakException()</span><br><span class="line">        &#125;</span><br><span class="line">        after += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: LoopBreakException) &#123;</span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">4</span>, before)</span><br><span class="line">assertEquals(<span class="number">3</span>, after)</span><br></pre></td></tr></table></figure>

<p>又不是不能用.jpg ，系统中断不也是这个思路吗？</p>
<h3 id="3-不提供不需要处理的数据"><a href="#3-不提供不需要处理的数据" class="headerlink" title="3. 不提供不需要处理的数据"></a>3. 不提供不需要处理的数据</h3><p>既然 <em>不处理不想要的数据</em> 行不通，那么我们应当换一个思路，考虑 <em>不提供不需要处理的数据</em> 这种做法。</p>
<p>首先复习一下 kotlin 给我们提供的集合的操作方法，知道它是可以通过链式调用 <code>map</code> <code>filter</code> <code>takeWhile</code> 等方式对数据进行预处理的，而 <code>takeWhile</code> 就是我们需要的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> before = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> after = <span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>.takeWhile &#123;</span><br><span class="line">    before += <span class="number">1</span></span><br><span class="line">    it.toInt() &lt;= <span class="number">2</span></span><br><span class="line">&#125;.forEach &#123;</span><br><span class="line">    it.toInt() <span class="comment">// let&#x27;s say you are parsing data with toInt()</span></span><br><span class="line">    after += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">3</span>, after) <span class="comment">// 0 1 2</span></span><br><span class="line">assertEquals(<span class="number">4</span>, before) <span class="comment">// 多一次判断，不符合条件后停止</span></span><br></pre></td></tr></table></figure>

<p>可以看到循环次数确实有了减少。</p>
<p>但是在示例中，为了判断是否中断需要解析数据（<code>String.toInt()</code>），在实际处理中又解析了一次。为了减少重复代码和处理消耗，我们应该充分利用链式调用，提前处理好数据：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> parsing = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> before = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> after = <span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>.map &#123;</span><br><span class="line">    parsing += <span class="number">1</span></span><br><span class="line">    it.toInt()</span><br><span class="line">&#125;.takeWhile &#123;</span><br><span class="line">    before += <span class="number">1</span></span><br><span class="line">    it &lt;= <span class="number">2</span></span><br><span class="line">&#125;.forEach &#123;</span><br><span class="line">    doYourBiz(it) <span class="comment">// let&#x27;s say you are parsing data with toInt()</span></span><br><span class="line">    after += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">3</span>, after) <span class="comment">// 0 1 2</span></span><br><span class="line">assertEquals(<span class="number">4</span>, before)<span class="comment">// 多一次判断，不符合条件后停止</span></span><br><span class="line">assertEquals(<span class="number">5</span>, parsing)</span><br></pre></td></tr></table></figure>

<p>在这里会发现，因为数据处理发生在 <code>takeWhile</code> 之前，而 <code>Collection</code> 的操作是先循环执行完前一段，再用结果作为新的集合去循环执行下一段，显然会有时间与内存上的消耗。</p>
<p>这里可以用 <code>Sequence</code> 做进一步的优化：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> parsing = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> before = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> after = <span class="number">0</span></span><br><span class="line"><span class="keyword">data</span>.asSequence()</span><br><span class="line">    .map &#123;</span><br><span class="line">    parsing += <span class="number">1</span></span><br><span class="line">    it.toInt()</span><br><span class="line">&#125;.takeWhile &#123;</span><br><span class="line">    before += <span class="number">1</span></span><br><span class="line">    it &lt;= <span class="number">2</span></span><br><span class="line">&#125;.forEach &#123;</span><br><span class="line">    doYourBiz(it) <span class="comment">// let&#x27;s say you are parsing data with toInt()</span></span><br><span class="line">    after += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">assertEquals(<span class="number">3</span>, after) <span class="comment">// 0 1 2</span></span><br><span class="line">assertEquals(<span class="number">4</span>, before)<span class="comment">// 多一次判断，不符合条件后停止</span></span><br><span class="line">assertEquals(<span class="number">4</span>, parsing)<span class="comment">// 同样是4次，停止后也不再执行后面的处理</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对 <code>Collection</code> 和 <code>Sequence</code> 的链式处理逻辑感兴趣的同学，可以自行将 parsing before after 打印出来，观察其中的区别。</p>
</blockquote>
<h2 id="总结：高效又优雅地实现中断"><a href="#总结：高效又优雅地实现中断" class="headerlink" title="总结：高效又优雅地实现中断"></a>总结：高效又优雅地实现中断</h2><p>归根结底，一开始想要在 <code>forEach</code> 中使用 <code>break</code> 是自己的观念没有转变好：在这种链式调用处理数据的函数式编程场景，仍然抱着指令式编程的观念。在这种情况下应该细分所需的业务逻辑，将其归类分层，才能写出简洁直观的代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">data</span> <span class="keyword">in</span> dataList) &#123;</span><br><span class="line">    <span class="keyword">val</span> parsed = parseData(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (shouldBreak(parsed)) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        yourBiz(parsed)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach后</span></span><br><span class="line">dataList.asSequence()</span><br><span class="line">    .map &#123;</span><br><span class="line">        parseData(it)</span><br><span class="line">    &#125;.takeWhile &#123;</span><br><span class="line">        !shouldBreak(it)</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        yourBiz(it)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Java 1.8 后提供的 <code>stream</code> 流也有上述类似的概念，本文也可供参考。</p>
<h2 id="进阶：中断前的特殊处理"><a href="#进阶：中断前的特殊处理" class="headerlink" title="进阶：中断前的特殊处理"></a>进阶：中断前的特殊处理</h2><p>上面讨论的情况是满足 <code>break</code> 条件后即退出，然而现实的需求总会超过你最坏的想象。</p>
<p>考虑这样一个场景：满足需要中断条件的数据并不是 <em>不需要处理的第一个数据</em>， 而是 <em>需要另一种处理方式的最后一个数据</em>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">data</span> <span class="keyword">in</span> dataList) &#123;</span><br><span class="line">    <span class="keyword">val</span> parsed = parseData(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">if</span> (shouldBreak(parsed)) &#123;</span><br><span class="line">        anotherBiz(parsed)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        yourBiz(parsed)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-将中断数据纳入数据流"><a href="#1-将中断数据纳入数据流" class="headerlink" title="1. 将中断数据纳入数据流"></a>1. 将中断数据纳入数据流</h3><p>首先我们需要考虑的，是将这个特殊的中断数据加入到数据流中。思路是在 <code>takeWhile</code> 遇到中断数据时仍然返回 <code>true</code> ，然后在随后的第一个数据里返回 <code>false</code> ，这需要一个变量帮助：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakFlag = <span class="literal">false</span></span><br><span class="line">dataList</span><br><span class="line">    .asSequence()</span><br><span class="line">    .map &#123;</span><br><span class="line">        parseData(it)</span><br><span class="line">    &#125;.takeWhile &#123;</span><br><span class="line">        <span class="keyword">val</span> tmpBreak = breakFlag</span><br><span class="line">        breakFlag = !shouldBreak(it)</span><br><span class="line">        !tmpBreak</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldBreak(it)) &#123;</span><br><span class="line">            anotherBiz(it)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            yourBiz(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这种实现方式中，<code>shouldBreak()</code> 被调用了 2n + 1  次，如果这个判断也比较耗时的话，可以有进一步的优化。</p>
<h3 id="2-将判断结果与数据绑定"><a href="#2-将判断结果与数据绑定" class="headerlink" title="2. 将判断结果与数据绑定"></a>2. 将判断结果与数据绑定</h3><p>上一节的代码中，每个有效数据都被判定了 2 次，想要节省这部分的时间，那么需要将第一次的判定结果保存下来，可以考虑的方式有：</p>
<ol>
<li>在原数据结构中增加一个标识位字段；</li>
<li>定义一个新的数据类同时保存判定结果和数据；</li>
<li>使用 <code>kotlin</code> 提供的 <code>Pair</code>。</li>
</ol>
<p>在这里使用3是最方便的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parsing = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> bizCall = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> anoBizCall = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseData</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    parsing += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">data</span>.toInt()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">shouldBreak</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> = <span class="keyword">data</span> == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">yourBiz</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    bizCall += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">anotherBiz</span><span class="params">(<span class="keyword">data</span>: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    anoBizCall += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> dataList = List(<span class="number">5</span>) &#123; it.toString() &#125;</span><br><span class="line"><span class="keyword">var</span> breakFlag = <span class="literal">false</span></span><br><span class="line">dataList</span><br><span class="line">    .asSequence()</span><br><span class="line">    .map &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = parseData(it)</span><br><span class="line">        shouldBreak(<span class="keyword">data</span>) to <span class="keyword">data</span></span><br><span class="line">    &#125;.takeWhile &#123; (lastData, <span class="keyword">data</span>) -&gt;</span><br><span class="line">        <span class="keyword">val</span> tmpBreak = breakFlag</span><br><span class="line">        breakFlag = lastData</span><br><span class="line">        !tmpBreak</span><br><span class="line">    &#125;.forEach &#123; (dataFlag, <span class="keyword">data</span>) -&gt;</span><br><span class="line">        <span class="keyword">if</span> (dataFlag) &#123;</span><br><span class="line">            anotherBiz(<span class="keyword">data</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            yourBiz(<span class="keyword">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">assertEquals(<span class="number">4</span>, parsing)</span><br><span class="line">assertEquals(<span class="number">2</span>, bizCall)</span><br><span class="line">assertEquals(<span class="number">1</span>, anoBizCall)</span><br></pre></td></tr></table></figure>

<h3 id="3-如何避免-if-的使用"><a href="#3-如何避免-if-的使用" class="headerlink" title="3. 如何避免 if 的使用"></a>3. 如何避免 <code>if</code> 的使用</h3><p>2 中的代码在 <code>forEach</code> 块中使用了条件语句，我们也可以尝试在代码中将其去除，使用到的是 <code>partition</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakFlag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">val</span> (commonData, lastData) = dataList</span><br><span class="line">    .asSequence()</span><br><span class="line">    .map &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = parseData(it)</span><br><span class="line">        shouldBreak(<span class="keyword">data</span>) to <span class="keyword">data</span></span><br><span class="line">    &#125;.takeWhile &#123; (lastData, <span class="keyword">data</span>) -&gt;</span><br><span class="line">        <span class="keyword">val</span> tmpBreak = breakFlag</span><br><span class="line">        breakFlag = lastData</span><br><span class="line">        !tmpBreak</span><br><span class="line">    &#125;.partition &#123; (lastData, <span class="keyword">data</span>) -&gt; !lastData &#125;</span><br><span class="line">commonData.forEach &#123; yourBiz(it.second) &#125;</span><br><span class="line">lastData.map &#123; (_, <span class="keyword">data</span>) -&gt; <span class="keyword">data</span> &#125;.forEach &#123; anotherBiz(it) &#125; <span class="comment">// 也可以用map来取出数据</span></span><br></pre></td></tr></table></figure>

<p>虽然我们尝试的是去除 <code>if</code> ，但在原本的数据流中也确实混杂了两种需要分别处理的数据，虽然可以使用 <code>partition</code> 进行分流然后分别处理，但这里将其结果取出然后分别遍历处理后，也实在是算不上是一次连贯完整的链式调用了。与使用条件语句相比，我也判断不出两种方式孰优孰劣，就由读者自行结合业务判断了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何将一坨 <code>for</code> 循环代码转换成优雅高效的 <code>forEach</code> 与链式调用结合起来，十分考验开发人员对于业务逻辑的归纳提炼能力，具体的实践其实与业务关系很大，免不了具体情况具体分析，而本文也仅仅是提供一些思路，希望能有所启发。</p>
</div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>Kotlin 中 forEach 的中断</p><p><span>文章作者：</span>Xiao</p><p><span>发布时间：</span>2019-07-11</p><p><span>最后更新：</span>2023-12-04</p><p><span>原始链接：</span><a href="/blog/kotlin-loop-break/">https://blog.xiaozk.site/blog/kotlin-loop-break/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://blog.xiaozk.site/blog/kotlin-loop-break/"></i></span></p><p><span>版权声明：</span><a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议（CC-BY-NC-4.0）</a>进行许可。</a></p></div><br><div class="tags"><a href="/tags/kotlin/"><i class="fa fa-tag"></i>kotlin</a><a href="/tags/forEach/"><i class="fa fa-tag"></i>forEach</a><a href="/tags/java/"><i class="fa fa-tag"></i>java</a><a href="/tags/stream/"><i class="fa fa-tag"></i>stream</a></div><div class="post-nav"><a class="pre" href="/blog/item-touch-helper-section/">ItemTouchHelper实现拖动分组与定制</a><a class="next" href="/blog/recyclerview_callback/">RecyclerView 中 ViewHolder 的异步回调实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://blog.xiaozk.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a> <a href="/tags/Callback/" style="font-size: 15px;">Callback</a> <a href="/tags/kotlin/" style="font-size: 15px;">kotlin</a> <a href="/tags/forEach/" style="font-size: 15px;">forEach</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/stream/" style="font-size: 15px;">stream</a> <a href="/tags/Unittest/" style="font-size: 15px;">Unittest</a> <a href="/tags/Powermock/" style="font-size: 15px;">Powermock</a> <a href="/tags/mock-rule/" style="font-size: 15px;">mock rule</a> <a href="/tags/RuleChain/" style="font-size: 15px;">RuleChain</a> <a href="/tags/ItemTouchHelper/" style="font-size: 15px;">ItemTouchHelper</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Constructor/" style="font-size: 15px;">Constructor</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/lambda/" style="font-size: 15px;">lambda</a> <a href="/tags/xml/" style="font-size: 15px;">xml</a> <a href="/tags/layout/" style="font-size: 15px;">layout</a> <a href="/tags/drawable/" style="font-size: 15px;">drawable</a> <a href="/tags/color/" style="font-size: 15px;">color</a> <a href="/tags/selector/" style="font-size: 15px;">selector</a> <a href="/tags/ItemAnimator/" style="font-size: 15px;">ItemAnimator</a> <a href="/tags/coroutine/" style="font-size: 15px;">coroutine</a> <a href="/tags/%E5%AE%89%E5%8D%93/" style="font-size: 15px;">安卓</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 15px;">协程</a> <a href="/tags/RenderNode/" style="font-size: 15px;">RenderNode</a> <a href="/tags/Canvas/" style="font-size: 15px;">Canvas</a> <a href="/tags/State/" style="font-size: 15px;">State</a> <a href="/tags/Event/" style="font-size: 15px;">Event</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/Flow/" style="font-size: 15px;">Flow</a> <a href="/tags/ItemDecoration/" style="font-size: 15px;">ItemDecoration</a> <a href="/tags/Animation/" style="font-size: 15px;">Animation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/shate-and-event/">我对“状态”与“事件”的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-render-node/">在 Android 中使用 Render Node 加速渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/coroutine-task/">使用协程组合管理业务逻辑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animate-decoration/">RecyclerView 中为 ItemDecoration 应用动画</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/recycler-animator-click/">RecyclerView 的 item 在动画过程中的点击事件</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-drawable-color-selector/">Android xml 中 drawable、color 的混用与 selector</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/kotlin-lambda-param/">kotlin 中传入形参、返回不匹配的 lambda 表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/thoughts-of-android-mvvm/">Android 项目中使用 MVVM 模式的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/java-override-constructor/">java 构造方法的重载</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/android-test-rule-order/">Android 使用Powermock的单元测试的 Rule 顺序</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Xiao's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>